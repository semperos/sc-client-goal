ari.prompt:"sc> "
url:"https://api.app.shortcut.com/api/v3/"; tok: 'env "SHORTCUT_API_TOKEN"
aj:"application/json"; hd:..["Shortcut-Token":tok;Accept:aj;"Content-Type":aj]; hc:http.client[..[Header:hd]]
hp:{[f]{[httpf;path]r: 'httpf[hc;url+path]; 'json r"string"}[f]}
hpp:{[f]{[httpf;path;reqopts]r: 'httpf[hc;url+path;reqopts]; 'json r"string"}[f]}
get:hp[http.get]; post:hpp[http.post]; put:hpp[http.put]; browse:{[ent]u:ent"app_url"; shell "open $u"}
sg:{[s]or[..["stories":"story"]s;-1_s]}; infi:1=sign; / singular, infinity-to-int
ist:{and["d"=@x;&/"s"=@'!x;&/{(@'x)Â¿"ANSI"}x;&/(*ls)=ls:#'x]}; mkt:{[D]ks:!*D; ks!+.'D} / is table / mk table
/ Strings
etk:"entity_type"; ens:!"custom-fields epic-workflows epics groups iterations key-results labels members objectives stories workflows"; es:(!"cf ew ep gr it kr lb mb ob st wf")!ens; abbs:+sg'es
stsfields:!"archived completed_at_end completed_at_start created_at_end created_at_start deadline_end deadline_start epic_id epic_ids estimate external_id group_id group_ids includes_description iteration_id iteration_ids label_ids label_name owner_id owner_ids project_id project_ids requested_by_id story_type updated_at_end updated_at_start workflow_state_id workflow_state_types"
idfs:(!"d s n")!({id:x"id";?["s"=@id;id;$"i"$id]};{x};{$"i"$x}); id:{tp:@x; ?[|/tp=!idfs;idfs[tp]x;$x]} / fmt ids
et:{x[etk]}
entn:{n:x"name"; ?[n="";x["profile";"name"];n]}
entprstr:{et:x[etk]; abb:abbs[et]; i:id[x]; n:entn x; "$abb[$i] / $n"}
epr:{et:x[etk]; abb:abbs[et]; i:id[x]; :qq/$abb["$i"]/}
/ TODO Brittle.
/ ari.print:{and[ist x;:fmt.tbl[x;3;3;"%.1f"]]; and["d"=@x;:(?[|/etk=!x;(et:x[etk];say entprstr[x]);say x])]; and["e"=@x;:(say x; say"")]; say $x}
pp:fmt.tbl[;3;3;"%.1f"]
ce::0n; cd:{ce::x; (ari.prompt::epr[x]+"> "); x};
san:{sub[rx/[^a-zA-Z0-9]/;""]x}; jp:{say " "json x}; / sanitize Goal name / print JSON (of ent)
fetcher:{[abbrev;arg]p:es[abbrev];u:?[""~arg;p;p+"/"+id[arg]];get u}
poster:{[abbrev;body]b:""json body; u:es[abbrev]; post[u;..[Body:b]]}
putter:{[abbrev;arg;body]u:es[abbrev]+"/"+id[arg]; b:""json body; ; put[u;..[Body:b]]}
/ TODO Add help for fetcher, putter, poster
/ TODO Consider st.*, ep.*, instead of everything under sc.*
{::[x;fetcher[x]]; ::["sc."+x;fetcher[x]]}'!es; / DEF API ent fetchers, w/wout pfx
{::[x;poster[x]]; ::["sc.create"+x;poster[x]]}'!es; / DEF API ent posters, w/wout pfx
{::[x;putter[x]]; ::["sc.update"+x;putter[x]]}'!es; / DEF API ent putters, w/wout pfx
/ DELETE endpoints intentionally unsupported. Archive via PUT as needed.
sc.member:{get"member"} / token's member
sc.ws:{(sc.member"")["workspace2";"url_slug"]} / workspace slug
sth:{[st]i:id[st]; get"stories/$i/history"}
/ TODO Make sc.q* functions that pluck out IDs from entity args
stsglobals:{[fld]k:"sts."+san[fld]; ::[k;fld]}; stsglobals'stsfields / DEF story search fields
sts:{[queryd]body:""json queryd; post["stories/search";..[Body:body]]} / API story search
itstories:{[it]i:id[it]; get"iterations/$i/stories"}
lb.put:{[lb;body]i:id lb;b:""json body; put["labels/$i";..[Body:b]]}
lb.st:{[lb]i:id lb; get"labels/$i/stories"}; lb.ep:{[lb]i:id lb; get"labels/$i/epics"}
st.wfsttype:{[type;st] wfst:st"workflow_state_id";type=wfsts[wfst]"type"} / expects global wfsts which is in scdata.ari
st.backlog:st.wfsttype"backlog"; st.done:st.wfsttype"done"; st.started:st.wfsttype"started"; st.unstarted:st.wfsttype"unstarted"
ep.wfsttype:{[type;ep] id:ep"epic_state_id"; type=epsts[id]"type"} / expects global epsts which is in scdata.ari
ep.done:ep.wfsttype"done"; ep.started:ep.wfsttype"started"; ep.unstarted:ep.wfsttype"unstarted"
